// vim:ts=4:sw=4:et:cin

#include "streamdeckkey.h"
#include <iostream>
#include <QBuffer>
#include <QPen>
#include <QPainter>
#include <QTimer>
#include "streamdeckconnect.h"

StreamDeckKey::StreamDeckKey(
        StreamDeckConnect* owner,
        const QString& deckId_, int page_, int row_, int column_,
        QImage&& icon)
    : QObject(owner)
    , deckConnect(owner)
    , deckId(deckId_), page(page_), row(row_), column(column_)
    , image(std::move(icon))
{
}

StreamDeckKey_LongPress::StreamDeckKey_LongPress(
        StreamDeckConnect* owner,
        const QString& deckId_, int page_, int row_, int column_,
        QImage&& icon, QImage&& iconLongPress)
    : StreamDeckKey(owner, deckId_, page_, row_, column_, std::move(icon))
    , imageLongPress(std::move(iconLongPress))
{
    connect(this, &StreamDeckKey::keyDown, this, &StreamDeckKey_LongPress::detectLongPress_onKeyDown);
    connect(this, &StreamDeckKey::keyUp,   this, &StreamDeckKey_LongPress::detectLongPress_onKeyUp  );
}

StreamDeckKey_Switch::StreamDeckKey_Switch(
        StreamDeckConnect* owner,
        const QString& deckId_, int page_, int row_, int column_,
        QImage&& iconOff, QImage&& iconOn,
        bool defaultEn)
    : StreamDeckKey(owner, deckId_, page_, row_, column_, std::move(iconOff))
    , imageOn(std::move(iconOn))
    , en(defaultEn)
{
}

StreamDeckKey_Scene::StreamDeckKey_Scene(
        StreamDeckConnect* owner,
        const QString& deckId_, int page_, int row_, int column_,
        QImage&& iconOff, QImage&& iconOn,
        uint_fast8_t sceneId)
    : StreamDeckKey_Switch(owner, deckId_, page_, row_, column_, std::move(iconOff), std::move(iconOn)), scene(sceneId)
{
}

StreamDeckKey_Tally::StreamDeckKey_Tally(
        StreamDeckConnect* owner,
        const QString& deckId_, int page_, int row_, int column_,
        QImage&& iconOff, QImage&& iconOn, QImage&& iconPreview,
        int camId_, bool isActive_, bool isPreview_)
    : StreamDeckKey(owner, deckId_, page_, row_, column_, QImage())
    , camId(camId_), isActive(isActive_), isPreview(isPreview_)
    , imageD(std::move(iconOff)), imageE(std::move(iconOn)), imageP(std::move(iconPreview))
{
}

StreamDeckKey_Preset::StreamDeckKey_Preset(
        StreamDeckConnect* owner,
        const QString& deckId_, int page_, int row_, int column_,
        QImage&& icon, unsigned presetNo_, bool isEnable_)
    : StreamDeckKey_LongPress(owner, deckId_, page_, row_, column_, QImage(), QImage())
    , presetNo(presetNo_), isEnable(isEnable_), image(std::move(icon))
{
}

void StreamDeckKey::onKeyDown()
{
    emit keyDown();
}

void StreamDeckKey::onKeyUp()
{
    emit keyUp();
}

void StreamDeckKey_LongPress::detectLongPress_onKeyDown()
{
    if (!timingLongPress) {
        timingLongPress = new QTimer(this);
        timingLongPress->setSingleShot(true);
        connect(timingLongPress, &QTimer::timeout, this, [this]() {
            _longPressed = true;
            updateButton();
            emit longPressed();
        });
        timingLongPress->start(1000);
    }
}

void StreamDeckKey_LongPress::detectLongPress_onKeyUp()
{
    if (timingLongPress) {
        delete timingLongPress;
        timingLongPress = nullptr;
    }
    if (_longPressed) {
        _longPressed = false;
        updateButton();
    }
}

QString StreamDeckKey::image2dataUri(const QImage& image) /* [static] */
{
    // function body is generated by Gemini
    if (image.isNull()) return QString();
    QByteArray byteArray;
    QBuffer buffer(&byteArray);
    buffer.open(QIODevice::WriteOnly);
    image.save(&buffer, "PNG"); 
    QString base64String = byteArray.toBase64();
    return "data:image/png;base64," + base64String; 
}

void StreamDeckKey::paintTextOnImage(QImage& image, const QString& str) /* [static] */
{
    // function body is generated by Gemini
    // Create a QPainter object
    QPainter painter(&image);

    // Set the pen and font for the text
    painter.setPen(QPen(Qt::white));
    painter.setFont(QFont("Noto Sans", 96));

    // Draw the text on the image
    painter.drawText(QRect(30,100,228,158), Qt::AlignCenter, str);
}

void StreamDeckKey::updateButton()
{
    deckConnect->sendRequest("setImage",
            QJsonObject{
                {"device", deckId},
                {"page", page},
                {"row", row},
                {"column", column},
                {"image", image2dataUri(image)}
            });
}

void StreamDeckKey_LongPress::updateButton()
{
    if (_longPressed) {
        deckConnect->sendRequest("setImage",
                QJsonObject{
                    {"device", deckId},
                    {"page", page},
                    {"row", row},
                    {"column", column},
                    {"image", image2dataUri(imageLongPress)}
                });
    } else {
        StreamDeckKey::updateButton();
    }
}

void StreamDeckKey_Switch::updateButton()
{
    if (en) {
        deckConnect->sendRequest("setImage",
                QJsonObject{
                    {"device", deckId},
                    {"page", page},
                    {"row", row},
                    {"column", column},
                    {"image", image2dataUri(imageOn)}
                });
    } else {
        StreamDeckKey::updateButton();
    }
}

void StreamDeckKey_Tally::updateButton()
{
    QImage copyImage(isActive? imageE : isPreview? imageP : imageD);
    if (camId >= 0) paintTextOnImage(copyImage, QString::number(camId));
    deckConnect->sendRequest("setImage",
            QJsonObject{
                {"device", deckId},
                {"page", page},
                {"row", row},
                {"column", column},
                {"image", image2dataUri(copyImage)}
            });
}

void StreamDeckKey_Preset::updateButton()
{
    if (isEnable && !isLongPressed()) {
        QImage copyImage(image);
        paintTextOnImage(copyImage, QString::number(presetNo));
        deckConnect->sendRequest("setImage",
                QJsonObject{
                    {"device", deckId},
                    {"page", page},
                    {"row", row},
                    {"column", column},
                    {"image", image2dataUri(copyImage)}
                });
    } else {
        deckConnect->sendRequest("setImage",
                QJsonObject{
                    {"device", deckId},
                    {"page", page},
                    {"row", row},
                    {"column", column}
                });
    }
}

void StreamDeckKey_Switch::setEnable(bool en_)
{
    if (en != en_) {
        en = en_;
        updateButton();
    }
}

void StreamDeckKey_Tally::setPreview(bool en)
{
    if (isPreview != en) {
        isPreview = en;
        updateButton();
    }
}

void StreamDeckKey_Tally::setActive(bool en)
{
    if (isActive != en) {
        isActive = en;
        updateButton();
    }
}

void StreamDeckKey_Tally::setCamId(int camId_, bool isActive_, bool isPreview_)
{
    if (camId != camId_ || isActive != isActive_ || isPreview != isPreview_) {
        camId = camId_;
        isActive = isActive_;
        isPreview = isPreview_;
        updateButton();
    }
}

void StreamDeckKey_Preset::setPresetNo(unsigned presetNo_, bool isEnable_)
{
    if (presetNo != presetNo_ || isEnable != isEnable_) {
        presetNo = presetNo_;
        isEnable = isEnable_;
        updateButton();
    }
}

